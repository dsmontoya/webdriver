/*
Selenium WebDriver

[Selenium WebDriver](https://www.w3.org/TR/webdriver) API specification

API version: 1.0.0
Contact: support@aerokube.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"fmt"
	"strings"
)


type ElementsApi interface {

	/*
	ElementClear Clear element

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiElementClearRequest
	*/
	ElementClear(ctx context.Context, sessionId string, elementId string) ElementsApiElementClearRequest

	// ElementClearExecute executes the request
	//  @return EmptyResponse
	ElementClearExecute(r ElementsApiElementClearRequest) (*EmptyResponse, *http.Response, error)

	/*
	ElementClick Click on element

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiElementClickRequest
	*/
	ElementClick(ctx context.Context, sessionId string, elementId string) ElementsApiElementClickRequest

	// ElementClickExecute executes the request
	//  @return EmptyResponse
	ElementClickExecute(r ElementsApiElementClickRequest) (*EmptyResponse, *http.Response, error)

	/*
	ElementSendKeys Send keys to element

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiElementSendKeysRequest
	*/
	ElementSendKeys(ctx context.Context, sessionId string, elementId string) ElementsApiElementSendKeysRequest

	// ElementSendKeysExecute executes the request
	//  @return EmptyResponse
	ElementSendKeysExecute(r ElementsApiElementSendKeysRequest) (*EmptyResponse, *http.Response, error)

	/*
	FindElement Find element

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@return ElementsApiFindElementRequest
	*/
	FindElement(ctx context.Context, sessionId string) ElementsApiFindElementRequest

	// FindElementExecute executes the request
	//  @return FindElementResponse
	FindElementExecute(r ElementsApiFindElementRequest) (*FindElementResponse, *http.Response, error)

	/*
	FindElementFromElement Find element from element

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiFindElementFromElementRequest
	*/
	FindElementFromElement(ctx context.Context, sessionId string, elementId string) ElementsApiFindElementFromElementRequest

	// FindElementFromElementExecute executes the request
	//  @return FindElementResponse
	FindElementFromElementExecute(r ElementsApiFindElementFromElementRequest) (*FindElementResponse, *http.Response, error)

	/*
	FindElements Find elements

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@return ElementsApiFindElementsRequest
	*/
	FindElements(ctx context.Context, sessionId string) ElementsApiFindElementsRequest

	// FindElementsExecute executes the request
	//  @return FindElementsResponse
	FindElementsExecute(r ElementsApiFindElementsRequest) (*FindElementsResponse, *http.Response, error)

	/*
	FindElementsFromElement Find elements from element

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiFindElementsFromElementRequest
	*/
	FindElementsFromElement(ctx context.Context, sessionId string, elementId string) ElementsApiFindElementsFromElementRequest

	// FindElementsFromElementExecute executes the request
	//  @return FindElementsResponse
	FindElementsFromElementExecute(r ElementsApiFindElementsFromElementRequest) (*FindElementsResponse, *http.Response, error)

	/*
	GetActiveElement Get active element

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@return ElementsApiGetActiveElementRequest
	*/
	GetActiveElement(ctx context.Context, sessionId string) ElementsApiGetActiveElementRequest

	// GetActiveElementExecute executes the request
	//  @return FindElementResponse
	GetActiveElementExecute(r ElementsApiGetActiveElementRequest) (*FindElementResponse, *http.Response, error)

	/*
	GetElementAttribute Get element attribute

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@param name Requested attribute name
	@return ElementsApiGetElementAttributeRequest
	*/
	GetElementAttribute(ctx context.Context, sessionId string, elementId string, name string) ElementsApiGetElementAttributeRequest

	// GetElementAttributeExecute executes the request
	//  @return NullableStringResponse
	GetElementAttributeExecute(r ElementsApiGetElementAttributeRequest) (*NullableStringResponse, *http.Response, error)

	/*
	GetElementCSSProperty Get element CSS property

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@param propertyName Requested CSS property name
	@return ElementsApiGetElementCSSPropertyRequest
	*/
	GetElementCSSProperty(ctx context.Context, sessionId string, elementId string, propertyName string) ElementsApiGetElementCSSPropertyRequest

	// GetElementCSSPropertyExecute executes the request
	//  @return StringResponse
	GetElementCSSPropertyExecute(r ElementsApiGetElementCSSPropertyRequest) (*StringResponse, *http.Response, error)

	/*
	GetElementComputedLabel Get element computed accessibility label

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiGetElementComputedLabelRequest
	*/
	GetElementComputedLabel(ctx context.Context, sessionId string, elementId string) ElementsApiGetElementComputedLabelRequest

	// GetElementComputedLabelExecute executes the request
	//  @return StringResponse
	GetElementComputedLabelExecute(r ElementsApiGetElementComputedLabelRequest) (*StringResponse, *http.Response, error)

	/*
	GetElementComputedRole Get element computed accessibility role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiGetElementComputedRoleRequest
	*/
	GetElementComputedRole(ctx context.Context, sessionId string, elementId string) ElementsApiGetElementComputedRoleRequest

	// GetElementComputedRoleExecute executes the request
	//  @return StringResponse
	GetElementComputedRoleExecute(r ElementsApiGetElementComputedRoleRequest) (*StringResponse, *http.Response, error)

	/*
	GetElementProperty Get element property

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@param name Requested property name
	@return ElementsApiGetElementPropertyRequest
	*/
	GetElementProperty(ctx context.Context, sessionId string, elementId string, name string) ElementsApiGetElementPropertyRequest

	// GetElementPropertyExecute executes the request
	//  @return NullableStringResponse
	GetElementPropertyExecute(r ElementsApiGetElementPropertyRequest) (*NullableStringResponse, *http.Response, error)

	/*
	GetElementRect Get element rect

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiGetElementRectRequest
	*/
	GetElementRect(ctx context.Context, sessionId string, elementId string) ElementsApiGetElementRectRequest

	// GetElementRectExecute executes the request
	//  @return RectResponse
	GetElementRectExecute(r ElementsApiGetElementRectRequest) (*RectResponse, *http.Response, error)

	/*
	GetElementTagName Get element tag name

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiGetElementTagNameRequest
	*/
	GetElementTagName(ctx context.Context, sessionId string, elementId string) ElementsApiGetElementTagNameRequest

	// GetElementTagNameExecute executes the request
	//  @return StringResponse
	GetElementTagNameExecute(r ElementsApiGetElementTagNameRequest) (*StringResponse, *http.Response, error)

	/*
	GetElementText Get element text

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiGetElementTextRequest
	*/
	GetElementText(ctx context.Context, sessionId string, elementId string) ElementsApiGetElementTextRequest

	// GetElementTextExecute executes the request
	//  @return StringResponse
	GetElementTextExecute(r ElementsApiGetElementTextRequest) (*StringResponse, *http.Response, error)

	/*
	IsElementDisplayed Is element displayed

	This operation is not considered a part of specification but is de-facto present in existing implementations.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiIsElementDisplayedRequest
	*/
	IsElementDisplayed(ctx context.Context, sessionId string, elementId string) ElementsApiIsElementDisplayedRequest

	// IsElementDisplayedExecute executes the request
	//  @return BooleanResponse
	IsElementDisplayedExecute(r ElementsApiIsElementDisplayedRequest) (*BooleanResponse, *http.Response, error)

	/*
	IsElementEnabled Is element enabled

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiIsElementEnabledRequest
	*/
	IsElementEnabled(ctx context.Context, sessionId string, elementId string) ElementsApiIsElementEnabledRequest

	// IsElementEnabledExecute executes the request
	//  @return BooleanResponse
	IsElementEnabledExecute(r ElementsApiIsElementEnabledRequest) (*BooleanResponse, *http.Response, error)

	/*
	IsElementSelected Is element selected

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId Requested session ID
	@param elementId Requested element ID
	@return ElementsApiIsElementSelectedRequest
	*/
	IsElementSelected(ctx context.Context, sessionId string, elementId string) ElementsApiIsElementSelectedRequest

	// IsElementSelectedExecute executes the request
	//  @return BooleanResponse
	IsElementSelectedExecute(r ElementsApiIsElementSelectedRequest) (*BooleanResponse, *http.Response, error)
}

// ElementsApiService ElementsApi service
type ElementsApiService service

type ElementsApiElementClearRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
	requestBody *map[string]map[string]interface{}
}

func (r ElementsApiElementClearRequest) RequestBody(requestBody map[string]map[string]interface{}) ElementsApiElementClearRequest {
	r.requestBody = &requestBody
	return r
}

func (r ElementsApiElementClearRequest) Execute() (*EmptyResponse, *http.Response, error) {
	return r.ApiService.ElementClearExecute(r)
}

/*
ElementClear Clear element

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiElementClearRequest
*/
func (a *ElementsApiService) ElementClear(ctx context.Context, sessionId string, elementId string) ElementsApiElementClearRequest {
	return ElementsApiElementClearRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return EmptyResponse
func (a *ElementsApiService) ElementClearExecute(r ElementsApiElementClearRequest) (*EmptyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.ElementClear")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/clear"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	fmt.Println("response body",string(localVarBody))
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiElementClickRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
	requestBody *map[string]map[string]interface{}
}

func (r ElementsApiElementClickRequest) RequestBody(requestBody map[string]map[string]interface{}) ElementsApiElementClickRequest {
	r.requestBody = &requestBody
	return r
}

func (r ElementsApiElementClickRequest) Execute() (*EmptyResponse, *http.Response, error) {
	return r.ApiService.ElementClickExecute(r)
}

/*
ElementClick Click on element

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiElementClickRequest
*/
func (a *ElementsApiService) ElementClick(ctx context.Context, sessionId string, elementId string) ElementsApiElementClickRequest {
	return ElementsApiElementClickRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return EmptyResponse
func (a *ElementsApiService) ElementClickExecute(r ElementsApiElementClickRequest) (*EmptyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.ElementClick")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/click"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiElementSendKeysRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
	elementSendKeysRequest *ElementSendKeysRequest
}

func (r ElementsApiElementSendKeysRequest) ElementSendKeysRequest(elementSendKeysRequest ElementSendKeysRequest) ElementsApiElementSendKeysRequest {
	r.elementSendKeysRequest = &elementSendKeysRequest
	return r
}

func (r ElementsApiElementSendKeysRequest) Execute() (*EmptyResponse, *http.Response, error) {
	return r.ApiService.ElementSendKeysExecute(r)
}

/*
ElementSendKeys Send keys to element

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiElementSendKeysRequest
*/
func (a *ElementsApiService) ElementSendKeys(ctx context.Context, sessionId string, elementId string) ElementsApiElementSendKeysRequest {
	return ElementsApiElementSendKeysRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return EmptyResponse
func (a *ElementsApiService) ElementSendKeysExecute(r ElementsApiElementSendKeysRequest) (*EmptyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmptyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.ElementSendKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/value"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.elementSendKeysRequest == nil {
		return localVarReturnValue, nil, reportError("elementSendKeysRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.elementSendKeysRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiFindElementRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	findElementRequest *FindElementRequest
}

func (r ElementsApiFindElementRequest) FindElementRequest(findElementRequest FindElementRequest) ElementsApiFindElementRequest {
	r.findElementRequest = &findElementRequest
	return r
}

func (r ElementsApiFindElementRequest) Execute() (*FindElementResponse, *http.Response, error) {
	return r.ApiService.FindElementExecute(r)
}

/*
FindElement Find element

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @return ElementsApiFindElementRequest
*/
func (a *ElementsApiService) FindElement(ctx context.Context, sessionId string) ElementsApiFindElementRequest {
	return ElementsApiFindElementRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return FindElementResponse
func (a *ElementsApiService) FindElementExecute(r ElementsApiFindElementRequest) (*FindElementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindElementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.FindElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.findElementRequest == nil {
		return localVarReturnValue, nil, reportError("findElementRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.findElementRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiFindElementFromElementRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
	findElementRequest *FindElementRequest
}

func (r ElementsApiFindElementFromElementRequest) FindElementRequest(findElementRequest FindElementRequest) ElementsApiFindElementFromElementRequest {
	r.findElementRequest = &findElementRequest
	return r
}

func (r ElementsApiFindElementFromElementRequest) Execute() (*FindElementResponse, *http.Response, error) {
	return r.ApiService.FindElementFromElementExecute(r)
}

/*
FindElementFromElement Find element from element

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiFindElementFromElementRequest
*/
func (a *ElementsApiService) FindElementFromElement(ctx context.Context, sessionId string, elementId string) ElementsApiFindElementFromElementRequest {
	return ElementsApiFindElementFromElementRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return FindElementResponse
func (a *ElementsApiService) FindElementFromElementExecute(r ElementsApiFindElementFromElementRequest) (*FindElementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindElementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.FindElementFromElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/element"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.findElementRequest == nil {
		return localVarReturnValue, nil, reportError("findElementRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.findElementRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiFindElementsRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	findElementRequest *FindElementRequest
}

func (r ElementsApiFindElementsRequest) FindElementRequest(findElementRequest FindElementRequest) ElementsApiFindElementsRequest {
	r.findElementRequest = &findElementRequest
	return r
}

func (r ElementsApiFindElementsRequest) Execute() (*FindElementsResponse, *http.Response, error) {
	return r.ApiService.FindElementsExecute(r)
}

/*
FindElements Find elements

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @return ElementsApiFindElementsRequest
*/
func (a *ElementsApiService) FindElements(ctx context.Context, sessionId string) ElementsApiFindElementsRequest {
	return ElementsApiFindElementsRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return FindElementsResponse
func (a *ElementsApiService) FindElementsExecute(r ElementsApiFindElementsRequest) (*FindElementsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindElementsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.FindElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/elements"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.findElementRequest == nil {
		return localVarReturnValue, nil, reportError("findElementRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.findElementRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiFindElementsFromElementRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
	findElementRequest *FindElementRequest
}

func (r ElementsApiFindElementsFromElementRequest) FindElementRequest(findElementRequest FindElementRequest) ElementsApiFindElementsFromElementRequest {
	r.findElementRequest = &findElementRequest
	return r
}

func (r ElementsApiFindElementsFromElementRequest) Execute() (*FindElementsResponse, *http.Response, error) {
	return r.ApiService.FindElementsFromElementExecute(r)
}

/*
FindElementsFromElement Find elements from element

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiFindElementsFromElementRequest
*/
func (a *ElementsApiService) FindElementsFromElement(ctx context.Context, sessionId string, elementId string) ElementsApiFindElementsFromElementRequest {
	return ElementsApiFindElementsFromElementRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return FindElementsResponse
func (a *ElementsApiService) FindElementsFromElementExecute(r ElementsApiFindElementsFromElementRequest) (*FindElementsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindElementsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.FindElementsFromElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/elements"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.findElementRequest == nil {
		return localVarReturnValue, nil, reportError("findElementRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.findElementRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiGetActiveElementRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
}

func (r ElementsApiGetActiveElementRequest) Execute() (*FindElementResponse, *http.Response, error) {
	return r.ApiService.GetActiveElementExecute(r)
}

/*
GetActiveElement Get active element

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @return ElementsApiGetActiveElementRequest
*/
func (a *ElementsApiService) GetActiveElement(ctx context.Context, sessionId string) ElementsApiGetActiveElementRequest {
	return ElementsApiGetActiveElementRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
//  @return FindElementResponse
func (a *ElementsApiService) GetActiveElementExecute(r ElementsApiGetActiveElementRequest) (*FindElementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FindElementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.GetActiveElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/active"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiGetElementAttributeRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
	name string
}

func (r ElementsApiGetElementAttributeRequest) Execute() (*NullableStringResponse, *http.Response, error) {
	return r.ApiService.GetElementAttributeExecute(r)
}

/*
GetElementAttribute Get element attribute

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @param name Requested attribute name
 @return ElementsApiGetElementAttributeRequest
*/
func (a *ElementsApiService) GetElementAttribute(ctx context.Context, sessionId string, elementId string, name string) ElementsApiGetElementAttributeRequest {
	return ElementsApiGetElementAttributeRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
		name: name,
	}
}

// Execute executes the request
//  @return NullableStringResponse
func (a *ElementsApiService) GetElementAttributeExecute(r ElementsApiGetElementAttributeRequest) (*NullableStringResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NullableStringResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.GetElementAttribute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/attribute/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiGetElementCSSPropertyRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
	propertyName string
}

func (r ElementsApiGetElementCSSPropertyRequest) Execute() (*StringResponse, *http.Response, error) {
	return r.ApiService.GetElementCSSPropertyExecute(r)
}

/*
GetElementCSSProperty Get element CSS property

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @param propertyName Requested CSS property name
 @return ElementsApiGetElementCSSPropertyRequest
*/
func (a *ElementsApiService) GetElementCSSProperty(ctx context.Context, sessionId string, elementId string, propertyName string) ElementsApiGetElementCSSPropertyRequest {
	return ElementsApiGetElementCSSPropertyRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
		propertyName: propertyName,
	}
}

// Execute executes the request
//  @return StringResponse
func (a *ElementsApiService) GetElementCSSPropertyExecute(r ElementsApiGetElementCSSPropertyRequest) (*StringResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.GetElementCSSProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/css/{propertyName}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyName"+"}", url.PathEscape(parameterToString(r.propertyName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiGetElementComputedLabelRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
}

func (r ElementsApiGetElementComputedLabelRequest) Execute() (*StringResponse, *http.Response, error) {
	return r.ApiService.GetElementComputedLabelExecute(r)
}

/*
GetElementComputedLabel Get element computed accessibility label

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiGetElementComputedLabelRequest
*/
func (a *ElementsApiService) GetElementComputedLabel(ctx context.Context, sessionId string, elementId string) ElementsApiGetElementComputedLabelRequest {
	return ElementsApiGetElementComputedLabelRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return StringResponse
func (a *ElementsApiService) GetElementComputedLabelExecute(r ElementsApiGetElementComputedLabelRequest) (*StringResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.GetElementComputedLabel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/computedlabel"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiGetElementComputedRoleRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
}

func (r ElementsApiGetElementComputedRoleRequest) Execute() (*StringResponse, *http.Response, error) {
	return r.ApiService.GetElementComputedRoleExecute(r)
}

/*
GetElementComputedRole Get element computed accessibility role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiGetElementComputedRoleRequest
*/
func (a *ElementsApiService) GetElementComputedRole(ctx context.Context, sessionId string, elementId string) ElementsApiGetElementComputedRoleRequest {
	return ElementsApiGetElementComputedRoleRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return StringResponse
func (a *ElementsApiService) GetElementComputedRoleExecute(r ElementsApiGetElementComputedRoleRequest) (*StringResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.GetElementComputedRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/computedrole"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiGetElementPropertyRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
	name string
}

func (r ElementsApiGetElementPropertyRequest) Execute() (*NullableStringResponse, *http.Response, error) {
	return r.ApiService.GetElementPropertyExecute(r)
}

/*
GetElementProperty Get element property

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @param name Requested property name
 @return ElementsApiGetElementPropertyRequest
*/
func (a *ElementsApiService) GetElementProperty(ctx context.Context, sessionId string, elementId string, name string) ElementsApiGetElementPropertyRequest {
	return ElementsApiGetElementPropertyRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
		name: name,
	}
}

// Execute executes the request
//  @return NullableStringResponse
func (a *ElementsApiService) GetElementPropertyExecute(r ElementsApiGetElementPropertyRequest) (*NullableStringResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NullableStringResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.GetElementProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/property/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiGetElementRectRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
}

func (r ElementsApiGetElementRectRequest) Execute() (*RectResponse, *http.Response, error) {
	return r.ApiService.GetElementRectExecute(r)
}

/*
GetElementRect Get element rect

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiGetElementRectRequest
*/
func (a *ElementsApiService) GetElementRect(ctx context.Context, sessionId string, elementId string) ElementsApiGetElementRectRequest {
	return ElementsApiGetElementRectRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return RectResponse
func (a *ElementsApiService) GetElementRectExecute(r ElementsApiGetElementRectRequest) (*RectResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RectResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.GetElementRect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/rect"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiGetElementTagNameRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
}

func (r ElementsApiGetElementTagNameRequest) Execute() (*StringResponse, *http.Response, error) {
	return r.ApiService.GetElementTagNameExecute(r)
}

/*
GetElementTagName Get element tag name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiGetElementTagNameRequest
*/
func (a *ElementsApiService) GetElementTagName(ctx context.Context, sessionId string, elementId string) ElementsApiGetElementTagNameRequest {
	return ElementsApiGetElementTagNameRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return StringResponse
func (a *ElementsApiService) GetElementTagNameExecute(r ElementsApiGetElementTagNameRequest) (*StringResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.GetElementTagName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/name"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiGetElementTextRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
}

func (r ElementsApiGetElementTextRequest) Execute() (*StringResponse, *http.Response, error) {
	return r.ApiService.GetElementTextExecute(r)
}

/*
GetElementText Get element text

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiGetElementTextRequest
*/
func (a *ElementsApiService) GetElementText(ctx context.Context, sessionId string, elementId string) ElementsApiGetElementTextRequest {
	return ElementsApiGetElementTextRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return StringResponse
func (a *ElementsApiService) GetElementTextExecute(r ElementsApiGetElementTextRequest) (*StringResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StringResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.GetElementText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/text"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiIsElementDisplayedRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
}

func (r ElementsApiIsElementDisplayedRequest) Execute() (*BooleanResponse, *http.Response, error) {
	return r.ApiService.IsElementDisplayedExecute(r)
}

/*
IsElementDisplayed Is element displayed

This operation is not considered a part of specification but is de-facto present in existing implementations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiIsElementDisplayedRequest
*/
func (a *ElementsApiService) IsElementDisplayed(ctx context.Context, sessionId string, elementId string) ElementsApiIsElementDisplayedRequest {
	return ElementsApiIsElementDisplayedRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return BooleanResponse
func (a *ElementsApiService) IsElementDisplayedExecute(r ElementsApiIsElementDisplayedRequest) (*BooleanResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.IsElementDisplayed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/displayed"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiIsElementEnabledRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
}

func (r ElementsApiIsElementEnabledRequest) Execute() (*BooleanResponse, *http.Response, error) {
	return r.ApiService.IsElementEnabledExecute(r)
}

/*
IsElementEnabled Is element enabled

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiIsElementEnabledRequest
*/
func (a *ElementsApiService) IsElementEnabled(ctx context.Context, sessionId string, elementId string) ElementsApiIsElementEnabledRequest {
	return ElementsApiIsElementEnabledRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return BooleanResponse
func (a *ElementsApiService) IsElementEnabledExecute(r ElementsApiIsElementEnabledRequest) (*BooleanResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.IsElementEnabled")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/enabled"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ElementsApiIsElementSelectedRequest struct {
	ctx context.Context
	ApiService ElementsApi
	sessionId string
	elementId string
}

func (r ElementsApiIsElementSelectedRequest) Execute() (*BooleanResponse, *http.Response, error) {
	return r.ApiService.IsElementSelectedExecute(r)
}

/*
IsElementSelected Is element selected

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId Requested session ID
 @param elementId Requested element ID
 @return ElementsApiIsElementSelectedRequest
*/
func (a *ElementsApiService) IsElementSelected(ctx context.Context, sessionId string, elementId string) ElementsApiIsElementSelectedRequest {
	return ElementsApiIsElementSelectedRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		elementId: elementId,
	}
}

// Execute executes the request
//  @return BooleanResponse
func (a *ElementsApiService) IsElementSelectedExecute(r ElementsApiIsElementSelectedRequest) (*BooleanResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BooleanResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ElementsApiService.IsElementSelected")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/session/{sessionId}/element/{elementId}/selected"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterToString(r.sessionId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"elementId"+"}", url.PathEscape(parameterToString(r.elementId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
